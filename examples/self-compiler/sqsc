#!/usr/bin/env sqs

# Main.

usage = '
Usage: {argv[0]} [option...] <file>

Options (both "option:" and "--option" forms are accepted):
	build-dir: <dir> 	(Where .o files, etc. go.)
	out: <file> 	(The name of the binary; defaults to "a.out")
	-o <file> 	(Same as "out: <file>".)
'.strip

build-dir = "build"

fn self-compiler-main()
	# Gather the command-line arguments.
	source-file = nil
	next-option = nil
	out-file = "a.out"
	for arg: argv.slice(1)
		if next-option
			if next-option == "build-dir"
				build-dir = arg
			else if next-option = "out"
				out-file = arg
			next-option = nil
			continue
		option-name = nil
		if arg.ends-with(":")
			option-name = arg.slice(0, -1)
		else if arg.starts-with("--")
			option-name = arg.slice(2)
		else if arg == "-o"
			option-name = "out"
		if option-name
			if option-name == "help"
				print(usage)
				return 0
			else if option-name == "out" || option-name == "build-dir"
				next-option = option-name
				continue
		# Anything else is the source file.
		if source-file
			print("You can only give one source file.")
			print(usage)
			return 1
		source-file = arg
	if !source-file
		print(usage)
		return 1

	# Compile.
	parser = Parser(File(source-file))
	ast = parser.parse-block
	$ mkdir -p {build-dir}
	write-main-fn(ast)
	build(out-file)
	# ast.dump

fn write-main-fn(ast)
	with file = File("{build-dir}/main.c", "w")
		builder = ProgramBuilder(GlobalContext(), file)
		builder.add('#include "sqs_compiled.h"')
		builder.add('')
		ast.resolve-names(builder)
		ast.emit-top-level(builder)

		# sqs_init_classes()
		builder.add("void sqs_init_classes()")
		builder.add(r"{")
		builder.indent
		for class-statement: builder.all-classes
			class-name = class-statement.c-name
			if class-statement.functions.size > 0
				builder.add("Class_add_builtin_methods(&{class-name}_class, {class-name}__builtin_methods_);")
		builder.dedent
		builder.add(r"}")
		builder.add("")

		# sqs_main()
		builder.add("Object* sqs_main(Object* self, Object** args)")
		builder.add(r"{")
		builder.indent()
		ast.emit(builder)
		builder.add("return NULL;")
		builder.dedent()
		builder.add(r"}")
		builder.add("")

fn build(out-file)
	cc = env["CC"] || "cc"
	sqs-source = env["SQS_SOURCE"]
	if !sqs-source
		fail("Please set $SQS_SOURCE in your environment.")
	self-compiler-source = env["SQS_COMPILER_SOURCE"] || "{sqs-source}/examples/self-compiler"
	if !Path("{self-compiler-source}/sqs_compiled.h").exists
		fail("Please set $SQS_COMPILER_SOURCE in your environment.")
	cflags = [ "-I{self-compiler-source}" "-I{sqs-source}" "-Wno-unused-result" ]
	link-flags = [ "-lgc" ]

	print("Compiling main.c...")
	$ {cc} {cflags} -c "{build-dir}/main.c" -o "{build-dir}/main.o"
	if !Path("{build-dir}/sqs_compiled.o").exists
		print("Compiling sqs_compiled.c...")
		$ {cc} {cflags} -c "{self-compiler-source}/sqs_compiled.c" -o "{build-dir}/sqs_compiled.o"
	o-files = [ "{build-dir}/main.o" "{build-dir}/sqs_compiled.o" ]
	sqs-files = "Object Class String Int Array Dict Boolean ByteArray Nil "
	sqs-files += "File Pipe Path Print Run Regex Glob MiscFunctions Fail Env "
	sqs-files += "BuiltinMethod Error UTF8 LinesIterator"
	for file: sqs-files.split
		o-file = "{build-dir}/{file}.o"
		o-files.append(o-file)
		if !Path(o-file).exists
			print("Compiling {file}.c...")
			$ {cc} {cflags} -c "{sqs-source}/{file}.c" -o {o-file}
	print("Linking...")
	$ {cc} {o-files} {link-flags} -o {out-file}


# Lexer.

# Lexer globals.
id = r"([[:alpha:]][[:alnum:]_-]*)|\$" 	# TODO: unicode.
num = r"-?(0x)?[0-9]+"
operator = r"\+=?|-=?|\*=?|/=?|%=?|\^=?|&(&|=)?|\|(\||=)?|\(|\)|\[|\]|\{|\}|==?|!=?|\.|,|:|~|<<?=?|>>?=?"
double-quote-string = r'r?"(\\.|[^"])*"'
single-quote-string = r"r?'(\\.|[^'])*'"
double-quote-string-contents = r'(\\.|[^"])*'
single-quote-string-contents = r"(\\.|[^'])*"
double-quote-string-start-re = Regex('^[ \t]*(r?"{double-quote-string-contents})$')
single-quote-string-start-re = Regex("^[ \t]*(r?'{single-quote-string-contents})$")
string-start-re = Regex("^[ \t]*(r?(\"{double-quote-string-contents}|'{single-quote-string-contents}))$")
double-quote-string-end-re = Regex('{double-quote-string-contents}"')
single-quote-string-end-re = Regex("{single-quote-string-contents}'")
token-re = Regex("^[ \t]*({id}|{num}|{operator}|{double-quote-string}|{single-quote-string})")
identifier-re = Regex("^{id}$")
operator-re = Regex("^({operator})$")
string-literal-re = Regex("^({double-quote-string}|{single-quote-string})$")
integer-re = Regex("^{num}$")
ignore-re = Regex(r"^[[:space:]]*(#.+)?$")
indentation-re = Regex(r"^([[:space:]]*).*$")

# Lexer special tokens.
eol = "#eol"
indent = "#indent"
dedent = "#dedent"

class Lexer
	(stream lines cur-line peeked-token line-number)
	(indent-stack unindent-to at-line-start paren-level)

	init(stream-in)
		stream = stream-in
		lines = stream.lines
		cur-line = lines.next
		line-number = 1
		indent-stack = []
		unindent-to = -1
		at-line-start = true
		paren-level = 0

	is-for-expression(line-number-in)
		at-line-start = false
		line-number = line-number-in

	next
		if peeked-token
			result = peeked-token
			peeked-token = nil
			return result
		return next-token

	peek
		if !peeked-token
			peeked-token = next-token
		return peeked-token

	next-token
		# EOF?
		if !cur-line
			if indent-stack.size > 0
				unindent-to = 0
			else
				return nil

		# Unindenting?
		if unindent-to >= 0
			if indent-stack.size == 0 || unindent-to == indent-stack.back
				# We're done unindenting.
				unindent-to = -1
			else
				# Unindent one more level.
				indent-stack.pop-back
				return dedent

		# Indenting?
		if at-line-start && paren-level == 0
			at-line-start = false

			# Consume empty lines before looking at indentation.
			while true
				if !ignore-re.match(cur-line)
					break
				cur-line = lines.next
				line-number += 1
				if !cur-line
					return nil

			# Figure out the indentation change.
			indentation = indentation-re.match(cur-line)[1].size
			if (indentation > 0 && indent-stack.size == 0) || indentation > indent-stack.back
				indent-stack.append(indentation)
				return indent
			else if indent-stack.size > 0 && indentation < indent-stack.back
				unindent-to = indentation
				indent-stack.pop-back
				return dedent

		# End of line?
		if ignore-re.match(cur-line)
			# Move to the next line.
			cur-line = lines.next
			line-number += 1
			at-line-start = true
			if paren-level > 0
				while ignore-re.match(cur-line)
					cur-line = lines.next
					line-number += 1
			else
				return eol

		# Next real token.
		match = token-re.match(cur-line)
		if !match
			if string-start-re.match(cur-line)
				return lex-multiline-string
			fail("Unknown characters on line {line-number}: {cur-line}")
		cur-line = match.remainder
		token = match[1]
		if token == "(" || token == "[" || token == r"{"
			paren-level += 1
		else if token == ")" || token == "]" || token == "}"
			paren-level -= 1
		at-line-start = false
		return token

	lex-multiline-string
		end-re = double-quote-string-end-re
		if single-quote-string-start-re.match(cur-line)
			end-re = single-quote-string-end-re
		quote-lines = [ string-start-re.match(cur-line)[1] ]
		while true
			cur-line = lines.next
			match = end-re.match(cur-line)
			if match
				quote-lines.append(match[0])
				cur-line = match.remainder
				break
			else
				quote-lines.append(cur-line)
		return quote-lines.join("\n")

	test
		while true
			token = next
			if !token
				break
			print("{line-number}: {token}")


# Parser

binop-levels = [
	[ "|" ], [ "^" ], [ "&" ],
	[ "==", "!=" ],
	[ "<" "<=" ">" ">=" ],
	[ "<<" ">>" ],
	[ "+", "-" ],
	[ "*" "/" "%" ],
	]
binops = {}
unop-precedence = 1
for level: binop-levels
	for op: level
		binops[op] = unop-precedence
	unop-precedence += 1

builtin-class-objects = [
	# Object, Class: these are not exposed by sqs by name.
	Array.superclass, Array.class.class,
	Int, Array, Dict,
	ByteArray, File, Pipe, Regex, Path,
	]
builtin-classes = {}
for the-class: builtin-class-objects
	builtin-classes[the-class.name] = the-class
builtin-fns = {
	print: "Print", run: "Run", fail: "Fail", glob: "Glob", sleep: "Sleep",
	getpid: "Getpid", cwd: "Get_cwd", chdir: "Chdir", rename: "Rename",
	}

class Parser
	(lexer)
	(inner-block)

	init(stream)
		lexer = Lexer(stream)

	parse-block
		# This is used for indented blocks, and the outermost level of a file.  If
		# called for an indented block, the indent must be consumed first.

		block = nil

		# Give access to the innermost block during parsing, so functions and
		# classes can be defined during the parse phase (so forward references will
		# work during the later emit/resolve phase).
		prev-inner-block = inner-block

		while true
			next-token = lexer.peek
			line-number = lexer.line-number
			if next-token == dedent || !next-token
				lexer.next
				break
			else if next-token == eol
				# Empty line.
				lexer.next
				continue

			# We're lazily making the block object, in case the block was nothing but
			# empty lines.
			if !block
				block = Block()
				inner-block = block

			statement = parse-statement
			if !statement
				fail("Statement expected at line {line-number}.")
			block.append(statement)

		inner-block = prev-inner-block
		return block

	parse-statement
		next-token = lexer.peek
		line-number = lexer.line-number
		if !next-token
			return nil

		if next-token == "if"
			return parse-if-statement
		else if next-token == "while"
			return parse-while-statement
		else if next-token == "for"
			return parse-for-statement
		else if next-token == "continue"
			return parse-continue-statement
		else if next-token == "break"
			return parse-break-statement
		else if next-token == "return"
			return parse-return-statement
		else if next-token == "with"
			return parse-with-statement
		else if next-token == "fn"
			return parse-fn-statement
		else if next-token == "class"
			return parse-class-statement
		else if next-token == "$"
			return parse-run-statement

		expression = parse-expression
		if !expression
			return nil
		next-token = lexer.next
		if next-token != eol
			fail("Extra characters after expression on line {lexer.line-number}")
		return expression

	parse-if-statement
		line-number = lexer.line-number
		lexer.next

		condition = parse-expression
		if !condition
			fail('Missing expression in "if" statement on line {line-number}')
		if lexer.next != eol
			fail("Extra characters after expression on line {line-number}")
		statement = IfStatement(condition)
		if lexer.peek == indent
			lexer.next
			statement.if-block = parse-block
		next-token = lexer.peek
		while next-token == eol
			lexer.next
			next-token = lexer.peek
		if next-token == "else"
			lexer.next
			next-token = lexer.peek
			if next-token == "if"
				statement.else-block = parse-if-statement
			else
				if next-token != eol
					fail('Extra tokens at end of "else" on line {lexer.line-number}')
				lexer.next
				if lexer.peek == indent
					lexer.next
					statement.else-block = parse-block
		else if next-token == "elif"
			# Don't consume the "elif"; the recursive call will do that.
			statement.else-block = parse-if-statement

		return statement

	parse-while-statement
		line-number = lexer.line-number
		lexer.next

		condition = parse-expression
		if !condition
			fail('Missing expression in "while" statement on line {line-number}')
		if lexer.next != eol
			fail('Extra characters after expression on line {line-number}')
		statement = WhileStatement()
		statement.condition = condition
		if lexer.peek == indent
			lexer.next
			statement.body = parse-block
		return statement

	parse-for-statement
		line-number = lexer.line-number
		lexer.next

		token = lexer.next
		if !identifier-re.match(token)
			fail('Need identifier for "for" statement on line {line-number}')
		statement = ForStatement(token)
		if lexer.next != ":"
			fail('Missing ":" in "for" statement on line {line-number}')
		statement.collection = parse-expression
		if !statement.collection
			fail('Missing expression in "for" statement on line {line-number}')
		if lexer.next != eol
			fail("Extra characters after expression on line {line-number}")
		if lexer.peek == indent
			lexer.next
			statement.body = parse-block

		return statement

	parse-continue-statement
		lexer.next
		return ContinueStatement()
	parse-break-statement
		lexer.next
		return BreakStatement()

	parse-return-statement
		lexer.next
		statement = ReturnStatement()
		statement.value = parse-expression
		if lexer.next != eol
			fail('Extra characters at end of "return" statement on line {lexer.line-number}')
		return statement

	parse-with-statement
		lexer.next
		line-number = lexer.line-number

		name = lexer.next
		if !identifier-re.match(name)
			fail('Expected a name in "with" statement on line {line-number}')
		if lexer.next != "="
			fail('Expected "=" in "with" statement on line {line-number}')
		expression = parse-expression
		if !expression
			fail('Expected expression in "with" statement on line {line-number}')
		if lexer.next != eol
			fail('Extra characters after expression on line {lexer.line-number}')
		body = nil
		if lexer.peek == indent
			lexer.next
			body = parse-block

		return WithStatement(name, expression, body)

	parse-fn-statement-raw
		# This could be in either a Block or a ClassStatement

		# Name and arguments
		name = parse-fn-name
		function = FunctionStatement(name)
		function.arguments = parse-names-list("argument")
		if lexer.next != eol
			fail('Extra characters at the end of a "fn" definition on line {lexer.line-number}')

		# Body
		if lexer.peek == indent
			lexer.next
			function.body = parse-block

		return function

	parse-fn-statement
		# This one is only used in a Block.
		lexer.next 	# Consume the "fn".
		function = parse-fn-statement-raw
		if inner-block
			inner-block.add-function(function)
		return function

	parse-class-statement
		lexer.next	# Consume "class".

		# Make sure new functions and classes don't end up in the enclosing block.
		prev-inner-block = inner-block
		inner-block = nil

		# Name.
		name = lexer.next
		if !identifier-re.match(name)
			fail('Expected class name on line {lexer.line-number}')
		statement = ClassStatement(name)

		# Superclass.
		if lexer.peek == ":"
			lexer.next
			token = lexer.next
			if !identifier-re.match(token)
				fail("Expected a class name as the superclass on line {lexer.line-number}")
			statement.superclass-name = token

		# Ivars.
		statement.ivars = parse-names-list("instance variable")

		if lexer.next != eol
			fail("Extra characters after class definition on line {lexer.line-number}")

		# Functions and classes.
		if lexer.peek == indent
			lexer.next
			while true
				token = lexer.peek
				if token == dedent
					lexer.next
					break
				else if token == eol
					lexer.next
					continue

				# Ivars.
				else if token == "("
					arg-names = parse-names-list("argument")
					if lexer.next != eol
						fail("Extra characters after ivars list on line {lexer.line-number}")
					if !statement.ivars
						statement.ivars = arg-names
					else
						for ivar: arg-names
							statement.ivars.append(ivar)
					continue

				# "class"
				else if token == "class"
					enclosed-class = parse-class-statement
					if !statement.enclosed-classes
						statement.enclosed-classes = {}
					statement.enclosed-classes[enclosed-class.name] = enclosed-class
					continue

				# Anything else is a function.
				# It might be preceded by "fn", or not.
				if token == "fn"
					lexer.next
					token = lexer.next
					if !identifier-re.match(token) && !operator-re.match(token)
						fail("Bad function definition on line {lexer.line-number}")

				function = parse-fn-statement-raw
				if !function
					fail("Expected function definition on line {lexer.line-number}")
				statement.functions[function.name] = function

		if prev-inner-block
			prev-inner-block.add-class(statement)

		inner-block = prev-inner-block
		return statement

	parse-run-command
		arguments = []
		while true
			token = lexer.peek
			if token == eol
				break
			if string-literal-re.match(token)
				arguments.append(parse-string-literal)
			else if identifier-re.match(token)
				lexer.next
				if token == "$"
					next-token = lexer.peek
					if next-token == "("
						arguments.append(parse-capture)
						continue
				arguments.append(StringLiteralExpr(token))
			else if integer-re.match(token)
				lexer.next
				arguments.append(StringLiteralExpr(token))
			else if operator-re.match(token)
				# Command-line options: Coalesce "-" or "+" with next identifier, "-", or "+".
				if token == "-" || token == "+"
					arg = token
					lexer.next
					while true
						token = lexer.peek
						if identifier-re.match(token) || integer-re.match(token)
							arg += token
							lexer.next
							break
						else if token == "-" || token == "+"
							arg += token
							lexer.next
						else
							break
					arguments.append(StringLiteralExpr(arg))

				# Expression inside "{}" or "()".
				else if token == r"{" || token == "("
					lexer.next
					arguments.append(parse-expression)
					end-token = "}"
					if token == "("
						end-token = ")"
					if lexer.next != end-token
						fail('Missing "{end-token}" on line {lexer.line-number}')

				# These end a command.
				else if [ "&&" "||" "|" ")" ].contains(token)
					break

				# Any other operator: just an argument.
				else
					lexer.next
					arguments.append(StringLiteralExpr(token))

			else
				fail('Unknown token in run command: "{token}"')

		if arguments.size == 0
			return nil
		return RunCommand(arguments)

	parse-run-pipeline
		command = parse-run-command
		if !command
			return nil

		pipeline = nil
		while true
			token = lexer.peek
			if token != "|"
				break
			lexer.next

			if !pipeline
				pipeline = RunPipeline()
				pipeline.commands.append(command)
			command = parse-run-command
			if !command
				fail('Missing command after "|" on line {lexer.line-number}')
			pipeline.commands.append(command)

		if pipeline
			return pipeline
		return command

	parse-run-statement
		line-number = lexer.line-number
		lexer.next

		statement = parse-run-pipeline
		if !statement
			fail('Empty "$" statement on line {line-number}')

		while true
			token = lexer.peek
			if token != "&&" && token != "||"
				break

			line-number = lexer.line-number
			lexer.next
			command-2 = parse-run-pipeline
			if !command-2
				fail('Empty command after "{token}" on line {line-number}')
			if statement.is-a(RunCommand) || statement.is-a(RunPipeline)
				statement = CallExpr(statement, "ok")
			statement = ShortCircuitExpression(statement, CallExpr(command-2, "ok"), (token == "&&"))

		if lexer.next != eol
			fail('Extra characters at the end of line {line-number}')
		return statement

	parse-expression
		expr = parse-logical-or-expression
		if !expr
			return nil

		next-token = lexer.peek
		if next-token == "="
			lexer.next
			if !expr.is-settable
				fail("Attempt to set something that isn't settable (line {lexer.line-number})")
			right = parse-expression
			if !right
				fail('Missing expression after "=" on line {lexer.line-number}')
			setter = SetExpr(expr, right)
			expr = setter

		# "+=" etc.
		else if [ "+=" "-=" "*=" "/=" "%=" "<<=" ">>=" "|=" "&=" "^=" ].contains(next-token)
			lexer.next
			if !expr.is-settable
				fail("Attempt to set something that isn't settable (line {lexer.line-number}")
			right = parse-expression
			if !right
				fail('Missing expression after "=" on line {lexer.line-number}')

			# Make the operation.
			op-name = next-token.slice(0, -1)
			call = CallExpr(expr, op-name, right)

			# Make the set.
			setter = SetExpr(expr, call)
			expr = setter

		return expr

	parse-logical-or-expression
		expr = parse-logical-and-expression
		if !expr
			return nil

		while true
			if lexer.peek != "||"
				break
			lexer.next

			expr2 = parse-logical-and-expression
			if !expr2
				fail('Missing expression after "||" on line {lexer.line-number}')
			expr = ShortCircuitExpression(expr, expr2, false)

		return expr

	parse-logical-and-expression
		expr = parse-binop(0)
		if !expr
			return nil

		while true
			if lexer.peek != "&&"
				break
			lexer.next

			expr2 = parse-binop(0)
			if !expr2
				fail('Missing expression after "&&" on line {lexer.line-number}')
			expr = ShortCircuitExpression(expr, expr2, true)

		return expr

	parse-binop(precedence)
		if precedence >= unop-precedence
			return parse-unop

		expr = parse-binop(precedence + 1)

		while true
			op-precedence = binops[lexer.peek]
			if !op-precedence || precedence > op-precedence
				break
			op = lexer.next
			right = parse-binop(op-precedence + 1)
			if !right
				fail('Missing expression after "{op}" on line {lexer.line-number}')
			expr = CallExpr(expr, op, right)

		return expr

	parse-unop
		next-token = lexer.peek
		if next-token == "!"
			lexer.next
			expr = parse-unop
			if !expr
				fail('Expected expression after "!" on line {lexer.line-number}')
			return ShortCircuitNot(expr)

		else if [ "~" "-" ].contains(next-token)
			lexer.next
			expr = parse-unop
			if !expr
				fail('Expected expression after "{next-token}" on line {lexer.line-number}')
			return CallExpr(expr, next-token)

		return parse-postfix-expression

	parse-postfix-expression
		expr = parse-primary
		if !expr
			return nil

		while true
			next-token = lexer.peek
			if next-token == "."
				expr = parse-dot-call(expr)
			else if next-token == "("
				expr = parse-fn-call(expr)
			else if next-token == "["
				expr = parse-index-call(expr)
			else
				break

		return expr

	parse-dot-call(receiver)
		lexer.next 	# Consume the "."

		# Name.
		token = lexer.next
		if !identifier-re.match(token)
			fail('Expected a name after "." on line {lexer.line-number}')
		call = CallExpr(receiver, token)

		# Parse the arguments (if there are any).
		if lexer.peek == "("
			call.arguments = parse-arguments
		call.got-args = true 	# We know we handled whatever arguments there may have been.

		return call

	parse-fn-call(function)
		return FunctionCallExpr(function, parse-arguments)

	parse-index-call(receiver)
		lexer.next 	# Consume the "[".

		call = CallExpr(receiver, "[]")
		index-expr = parse-expression
		if !index-expr
			fail('Expected expression after "[" on line {lexer.line-number}')
		call.add-argument(index-expr)

		# Finish.
		if lexer.next != "]"
			fail('Expected "]" on line {lexer.line-number}')
		return call

	parse-arguments
		line-number = lexer.line-number
		lexer.next 	# Consume "(".

		args = []
		need-comma = false
		while true
			# Next ")" or ",".
			next-token = lexer.peek
			if next-token == ")"
				lexer.next
				break
			if need-comma
				if !next-token
					fail('Unterminated argument list starting on line {line-number}')
				if next-token != ","
					fail('Comma expected between arguments on line {lexer.line-number}')
				lexer.next
				need-comma = false

			arg = parse-expression
			if !arg
				fail('Expected expression in argument list on line {lexer.line-number}')
			args.append(arg)
			need-comma = true

		return args

	parse-primary
		next-token = lexer.peek

		if string-literal-re.match(next-token)
			return parse-string-literal
		else if integer-re.match(next-token)
			lexer.next
			return IntLiteralExpr(next-token)

		else if identifier-re.match(next-token)
			lexer.next
			if next-token == "true"
				return BooleanLiteral(true)
			else if next-token == "false"
				return BooleanLiteral(false)
			else if next-token == "nil"
				return NilLiteral()
			else if next-token == "self"
				return SelfExpr()
			else if next-token == "super"
				return parse-super-call
			else if next-token == "$"
				if lexer.peek == "("
					return parse-capture
			return Variable(next-token, lexer.line-number)

		else if next-token == "["
			return parse-array-literal
		else if next-token == r"{"
			return parse-dict-literal
		else if next-token == "("
			start-line-number = lexer.line-number
			lexer.next
			expr = parse-expression
			if lexer.next != ")"
				fail('Missing ")" on line {start-line-number}')
			return expr

		return nil

	parse-string-literal
		# Process interpolations and escapes.

		# Raw string literal?
		token = lexer.next
		if token.slice(0, 1) == "r"
			return StringLiteralExpr(token.slice(2, -1))

		start-line-number = lexer.line-number
		remainder = token.slice(1, -1)
		segment-start = remainder
		segment-size = 0
		segments = []
		last-segment-is-literal = false
		fn next-char
			c = remainder.slice(0, 1)
			remainder = remainder.slice(1)
			return c
		fn add-literal-segment(str)
			if last-segment-is-literal
				segments.back.append(str)
			else
				segments.append(StringLiteralExpr(str))
				last-segment-is-literal = true
		fn finish-segment()
			if segment-size > 0
				add-literal-segment(segment-start.slice(0, segment-size))
			segment-start = remainder
			segment-size = 0

		while !remainder.is-empty
			c = next-char()

			if c == "\x5C" 	# Backslash; just getting around a syntax-hilighting bug...
				finish-segment()
				escape-mapping = {
					n: "\n", t: "\t", r: "\r", e: "\e", b: "\b", a: "\a", v: "\v", f: "\f"
					}
				escape-mapping["\x5C"] = "\x5C\x5C"
				c = next-char()
				mapping = escape-mapping[c]
				if mapping
					add-literal-segment(mapping)
				else if c == 'x'
					digits = "0x" + next-char()
					digits += next-char()
					value = Int(digits)
					byte-array = ByteArray()
					byte-array.append(value)
					add-literal-segment(byte-array.as-string)
				else if c == 'u' || c == 'U'
					num-digits = 4
					if c == 'U'
						num-digits = 8
					digits = "0x"
					while num-digits > 0
						digits += next-char()
						num-digits -= 1
					add-literal-segment(Int(digits).as-utf8)
				else
					add-literal-segment(c)
				segment-start = remainder

			else if c == r"{"
				finish-segment()
				if remainder.slice(0, 1) == r"{"
					# Escaping via "{{".
					add-literal-segment(next-char())
					segment-start = remainder
				else
					brace-level = 0
					segment-size = 0
					while !remainder.is-empty
						c = next-char()
						if c == r"{"
							brace-level += 1
						else if c == r"}"
							brace-level -= 1
							if brace-level <= 0
								break
						segment-size += 1
					if brace-level > 0
						fail("Unterminated string interpolation on line {start-line-number}")

					# Parse the expression.
					class SingleLineIterator
						(line)
						init(line-in)
							line = line-in
						next
							result = line
							line = nil
							return result
						lines
							return self
					parser = Parser(SingleLineIterator(segment-start.slice(0, segment-size)))
					parser.lexer.is-for-expression(start-line-number)
					expr = parser.parse-expression
					if expr
						segments.append(expr)

					last-segment-is-literal = false
					segment-start = remainder
					segment-size = 0

			else if c == r"}"
				finish-segment()
				if remainder.slice(0, 1) == "}"
					next-char()
				add-literal-segment(r"}")
				segment-start = remainder

			else
				segment-size += 1

		# Finish up.
		finish-segment()
		if segments.size == 1
			return segments[0]
		return InterpolatedStringLiteral(segments)

	parse-array-literal
		lexer.next
		array-literal = ArrayLiteral()

		while true
			next-token = lexer.peek
			if next-token == "]"
				lexer.next
				break
			else if next-token == ","
				lexer.next
				continue

			item = parse-expression
			if !item
				fail("Expected expression in array literal on line {lexer.line-number}")
			array-literal.add-item(item)

		return array-literal

	parse-dict-literal
		lexer.next
		dict-literal = DictLiteral()

		while true
			# Key.
			token = lexer.next
			if token == "}"
				break
			else if token == ","
				continue
			else if !identifier-re.match(token)
				fail("Expected name in Dict literal on line {lexer.line-number}")
			key = token

			# ":" or "="
			token = lexer.next
			if token != ":" && token != "="
				fail('Expected ":" or "=" in Dict literal on line {lexer.line-number}')

			# Value.
			value = parse-expression
			if !value
				fail('Expected value expression for "{key}" in Dict literal on line {lexer.line-number}')

			# Add it.
			dict-literal.add-item(key, value)

		return dict-literal

	parse-super-call
		# The "super" has already been consumed.

		# "."
		token = lexer.next
		if token != "."
			fail('Expected "." in "super" call on line {lexer.line-number}')

		# Name.
		name = parse-fn-name
		call = SuperCallExpr(name)

		# Arguments.
		if lexer.peek == "("
			call.arguments = parse-arguments

		return call

	parse-capture
		# Consume '('.
		lexer.next
		line-number = lexer.line-number

		pipeline = parse-run-pipeline
		if !pipeline
			fail('Expected a command or pipeline in "$()" on line {line-number}')
		if lexer.next != ")"
			fail('Missing ")" at end of "$()" on line {lexer.line-number}')
		return RunCapture(pipeline)


	parse-fn-name
		# Base name.
		name = lexer.next
		can-be-set = true
		if name == "["
			if lexer.next != "]"
				fail('Expected "[]" as a function name, not just "[", on line {lexer.line-number}')
			name = "[]"
		else if operator-re.match(name)
			can-be-set = false
		else if !identifier-re.match(name)
			fail('Expected a function name on line {lexer.line-number}')

		# Add "="?
		if can-be-set
			if lexer.peek == "="
				name += "="
				lexer.next

		return name

	parse-names-list(type)
		names = []
		if lexer.peek != "("
			return names

		lexer.next	# Consume "(".
		while true
			token = lexer.next
			if token == ")"
				break
			else if token == ","
				continue
			else if !identifier-re.match(token)
				fail('Expected {type} name on line {lexer.line-number}')
			names.append(token)

		return names


# Contexts.

class Context
	(parent)

	parent=(new-parent)
		parent = new-parent

	find(name)
		print("Unimplemented find() in {self.class.name}")
	find-autodeclaring(name)
		# Default: same as "find".
		return find(name)
	get-class-for-superclass(name, builder)
		return nil

	c-prefix
		# Default: this context doesn't introduce a new level of namespace.
		return parent && parent.c-prefix

	find-class-for-superclass(name, builder)
		context = self
		while context
			the-class = get-class-for-superclass(name, builder)
			if the-class
				return the-class
			context = context.parent
		return nil

class GlobalContext: Context
	find(name)
		builtin-class = builtin-classes[name]
		if builtin-class
			return BuiltinClass(builtin-class)
		c-name = builtin-fns[name]
		if c-name
			return BuiltinObject(c-name)
		if [ "env", "argv" ].contains(name)
			return BuiltinObject("(Object*) &{name}_obj")
		return nil

# ParseNodes

indent-spacers = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t"

class ParseNode
	emit(builder)
		fail('Called unimplemented "emit" on {self.class.name}')
	emit-set(value, builder)
		fail('Called unimplemented "emit-set" on {self.class.name}')
	emit-top-level(builder)
		# This is for functions and class declarations, that need to be at the top
		# level of the C file.
		# Default: nothing to do.
	emit-unwind(builder)
		# Default: most ParseNodes don't use this.
	resolve-names(builder)
		# Default: do nothing.
	resolve-names-autodeclaring(builder)
		# Default: same as resolve-names().
		resolve-names(builder)
	is-settable
		return false
	is-loop
		return false
	dump(level)
		if !level
			level = 0
		print("{indent-spacers.slice(0, level)}{self.class.name}")

next-capture-id = 1

class Block: ParseNode
	(statements locals functions classes)
	(capture-id, captured-locals)

	init
		statements = []
	append(statement)
		statements.append(statement)
	add-function(function)
		if !functions
			functions = {}
		functions[function.name] = function
	add-class(class-statement)
		if !classes
			classes = {}
		classes[class-statement.name] = class-statement
	get-local(name)
		return locals && locals[name]
	get-function(name)
		return functions && functions[name]
	get-class(name)
		return classes && classes[name]
	autodeclare(name)
		if !locals
			locals = {}
		local = Local(name)
		locals[name] = local
		return local
	dump(level)
		if !level
			level = 0
		super.dump(level)
		for statement: statements
			statement.dump(level + 1)

	emit(builder)
		# Emit local declarations.
		if locals && locals.size > 0
			local-specs = []
			for kv: locals
				local-specs.append("{mangle-name(kv.key)} = NULL")
			builder.add('Object_ptr {local-specs.join(", ")};')

		# Emit the captured locals.
		if captured-locals
			mangled-names = []
			for local-name: captured-locals
				mangled-names.append("&{mangle-name(local-name)}")
			builder.add("Object** captures_[] = {{ {mangled-names.join(', ')} }};")
			builder.add("UpvalFrame upval_frame_ = {{ {capture-id}, cur_upval_frame_, captures_ }};")
			builder.add("cur_upval_frame_ = &upval_frame_;")
			builder.push-unwinding(self)

		# Emit.
		for statement: statements
			statement.emit(builder)

		# Finish.
		if captured-locals
			builder.pop-unwinding(self)
			emit-unwind(builder)

	emit-top-level(builder)
		for statement: statements
			statement.emit-top-level(builder)

	emit-unwind(builder)
		if captured-locals
			builder.add("cur_upval_frame_ = cur_upval_frame_->up;")

	resolve-names(builder)
		builder.push-context(BlockContext(self))
		for statement: statements
			if statement.is-a(FunctionStatement) || statement.is-a(ClassStatement)
				# Add upvalues to the context.
				builder.push-context(BlockUpvalueContext(self))
				statement.resolve-names(builder)
				builder.pop-context
			else
				statement.resolve-names(builder)
		builder.pop-context

	capture-index(name)
		# Set up captures, if we haven't yet.
		if !captured-locals
			capture-id = next-capture-id
			next-capture-id += 1
			captured-locals = []

		# Find existing index, if there is one.
		index = 0
		for local-name: captured-locals
			if local-name == name
				break
			index += 1
		if index >= captured-locals.size
			captured-locals.append(name)
		return index

	class BlockContext: Context
		(block)

		init(block-in)
			block = block-in
		find(name)
			expr = block.get-local(name)
			if expr
				return expr
			function = block.get-function(name)
			if function
				# Treat it as a nullary function call.  FunctionCallExpr.emit will
				# append arguments if any are given.
				return FunctionCallExpr(FunctionRef(function), [])
			class-statement = block.get-class(name)
			if class-statement
				return ClassRef(class-statement)
			return parent && parent.find(name)
		find-autodeclaring(name)
			# Already declared here?
			expr = block.get-local(name)
			if expr
				return expr
			# Not declared here, search up the chain.
			expr = parent && parent.find(name)
			if expr
				return expr
			# Doesn't exist, so autodeclare it.
			return block.autodeclare(name)

	class BlockUpvalueContext: Context
		(block)

		init(block-in)
			block = block-in
		find(name)
			node = parent.find(name)
			if node && node.is-a(Local)
				# It's a local in the block's method, turn it into an upvalue.
				# If it were a local in an enclosing method, it would already be an
				# UpvalueLocal.
				node = UpvalueLocal(block, name)
			return node

	class UpvalueLocal: ParseNode
		(block, index)

		init(block-in, name)
			block = block-in
			index = block.capture-index(name)
		emit(builder)
			result = builder.new-temp
			builder.add("Object* {result} = *get_upvalue_({block.capture-id}, {index});")
			return result
		emit-set(value, builder)
			value-loc = value.emit(builder)
			builder.add("*get_upvalue_({block.capture-id}, {index}) = {value-loc};")
			return value-loc


class IfStatement: ParseNode
	(condition if-block else-block)

	init(condition-in)
		condition = condition-in
	if-block=(new-if-block)
		if-block = new-if-block
	else-block=(new-else-block)
		else-block = new-else-block

	resolve-names(builder)
		condition.resolve-names(builder)
		if if-block
			if-block.resolve-names(builder)
		if else-block
			else-block.resolve-names(builder)
	emit(builder)
		condition-loc = condition.emit(builder)
		if if-block
			builder.add("if (IS_TRUTHY({condition-loc})) {{")
			builder.indent
			if-block.emit(builder)
			builder.add(r"}")
			builder.dedent
			if else-block
				builder.add(r"else {")
				builder.indent
				else-block.emit(builder)
				builder.add(r"}")
				builder.dedent
		else if else-block
			builder.add("if (!IS_TRUTHY({condition-loc})) {{")
			builder.indent
			else-block.emit(builder)
			builder.add(r"}")
			builder.dedent
	emit-top-level(builder)
		if if-block
			if-block.emit-top-level(builder)
		if else-block
			else-block.emit-top-level(builder)

class WhileStatement: ParseNode
	(condition body)

	condition=(new-condition)
		condition = new-condition
	body=(new-body)
		body = new-body
	is-loop
		return true

	resolve-names(builder)
		condition.resolve-names(builder)
		if body
			body.resolve-names(builder)
	emit(builder)
		builder.add(r"while (true) {")
		builder.indent
		condition-loc = condition.emit(builder)
		builder.add("if (!IS_TRUTHY({condition-loc}))")
		builder.add("\tbreak;")
		builder.add("")
		if body
			body.emit(builder)
		builder.add(r"}")
		builder.dedent
	emit-top-level(builder)
		if body
			body.emit-top-level(builder)

class ForStatement: ParseNode
	(variable-name collection body)

	init(name)
		variable-name = name
	collection=(new-collection)
		collection = new-collection
	body=(new-body)
		body = new-body
	is-loop
		return true

	resolve-names(builder)
		builder.push-context(ForStatementContext(variable-name))
		collection.resolve-names(builder)
		if body
			body.resolve-names(builder)
		builder.pop-context
	emit(builder)
		collection-loc = collection.emit(builder)
		iterator-loc = builder.new-temp
		variable-loc = mangle-name(variable-name)
		builder.add('Object* {iterator-loc} = call_("iterator", {collection-loc}, 0, NULL);')
		builder.add(r"while (true) {")
		builder.indent
		builder.add('Object* {variable-loc} = call_("next", {iterator-loc}, 0, NULL);')
		builder.add('if (!{variable-loc})')
		builder.add('\tbreak;')
		builder.add("")
		if body
			body.emit(builder)
		builder.add(r"}")
		builder.dedent
	emit-top-level(builder)
		if body
			body.emit-top-level(builder)

	class ForStatementContext: Context
		(variable-name)
		init(variable-name-in)
			variable-name = variable-name-in
		find(name)
			if name == variable-name
				return RawLoc(mangle-name(variable-name))
			return parent.find(name)

class ContinueStatement: ParseNode
	emit(builder)
		builder.add("continue;")
class BreakStatement: ParseNode
	emit(builder)
		builder.add("break;")

class ReturnStatement: ParseNode
	(value)

	value=(new-value)
		value = new-value
	resolve-names(builder)
		if value
			value.resolve-names(builder)
	emit(builder)
		value-loc = "NULL"
		if value
			value-loc = value.emit(builder)
		builder.emit-unwind-function
		builder.add("return {value-loc};")

class WithStatement: ParseNode
	(name expr body unwind-loc)

	init(name-in, expr-in, body-in)
		name = name-in
		expr = expr-in
		body = body-in

	resolve-names(builder)
		builder.push-context(WithStatementContext(self))
		expr.resolve-names(builder)
		if body
			body.resolve-names(builder)
		builder.pop-context

	emit(builder)
		# We'll use a temporary for the unwinding, to make sure the name isn't
		# shadowed by a subblock.
		# We also make it it's own block, so the name doesn't end up in the outer scope.
		builder.add(r"{")
		expr-loc = expr.emit(builder)
		unwind-loc = builder.new-temp
		builder.add("Object* {unwind-loc} = {expr-loc};")
		builder.add("Object* {mangle-name(name)} = {unwind-loc};")
		if body
			builder.push-unwinding(self)
			body.emit(builder)
			builder.pop-unwinding(self)
		emit-unwind(builder)
		builder.add(r"}")

	emit-top-level(builder)
		if body
			body.emit-top-level(builder)

	emit-unwind(builder)
		builder.add('call_("close", {unwind-loc}, 0, NULL);')

	class WithStatementContext: Context
		(with-statement)
		init(with-statement-in)
			with-statement = with-statement-in
		find(name)
			if name == with-statement.name
				return RawLoc(mangle-name(name))
			return parent && parent.find(name)

class FunctionStatement: ParseNode
	(name arguments body c-name)

	init(name-in)
		name = name-in
	arguments=(new-arguments)
		arguments = new-arguments
	body=(new-body)
		body = new-body

	resolve-names(builder)
		context = FunctionContext(self)
		builder.push-context(context)
		c-name = context.c-prefix
		if body
			body.resolve-names(builder)
		builder.pop-context

	emit-top-level(builder)
		if body
			body.emit-top-level(builder)

		builder.add("Object* {c-name}(Object* self, Object** args_)")
		builder.add(r"{")
		builder.indent
		if arguments
			index = 0
			for arg: arguments
				builder.add("Object* {mangle-name(arg)} = args_[{index}];")
				index += 1
		if body
			body.emit(builder)
		if (name == "init")
			builder.add("return self;")
		else
			builder.add("return NULL;")
		builder.dedent
		builder.add(r"}")
		builder.add("")

	emit(builder)
		# Everything is emitted in emit-top-level(), and anything referencing the
		# function will use FunctionRef, so nothing needs to be done here.

	class FunctionContext: Context
		(function-statement)
		init(function-statement-in)
			function-statement = function-statement-in
		find(name)
			if function-statement.arguments
				if function-statement.arguments.contains(name)
					return RawLoc(mangle-name(name))
			return parent && parent.find(name)
		c-prefix
			prefix = parent && parent.c-prefix
			fn-c-name = mangle-name(function-statement.name)
			if prefix
				return "{prefix}__{fn-c-name}"
			return fn-c-name

class ClassStatement: ParseNode
	(name, superclass-name, superclass, ivars, functions, enclosed-classes, c-name)

	init(name-in)
		name = name-in
		functions = {}
	superclass-name=(new-superclass-name)
		superclass-name = new-superclass-name
	ivars=(new-ivars)
		ivars = new-ivars
	enclosed-classes=(new-enclosed-classes)
		enclosed-classes = new-enclosed-classes
	get-ivar(name)
		if ivars && ivars.contains(name)
			return IvarExpr(name)
		return nil
	total-ivars
		num-ivars = 0
		if superclass
			num-ivars += superclass.total-ivars
		if ivars
			num-ivars += ivars.size
		return num-ivars
	c-ivar-index-name(name)
		if ivars && ivars.contains(name)
			return "{c-name}_{mangle-name(name)}__index"
		return superclass && superclass.c-ivar-index-name(name)

	emit-top-level(builder)
		enclosing-class = builder.cur-class
		builder.cur-class = self
		builder.add-class(self)

		# Class object.
		builder.add('declare_static_string({c-name}_class_name_, "{name}");')
		ivars-names-loc = "NULL"
		if ivars && ivars.size > 0
			ivars-list = []
			for ivar: ivars
				ivars-list.append('inline_string_("{ivar}")')
			ivars-list = '{{ {ivars-list.join(", ")} }}'
			builder.add('Array {c-name}_ivar_names_ = {{ &Array_class, {ivars.size}, {ivars.size}, (Object*[]) {ivars-list} }};')
			ivars-names-loc = "&{c-name}_ivar_names_"
		builder.add("Class {c-name}_class = {{")
		builder.indent
		builder.add('&Class_class,')
		builder.add('&{c-name}_class_name_,')
		if superclass
			builder.add("&{superclass.c-name}_class,")
		else
			builder.add('NULL,')
		builder.add('NULL,')
		builder.add("{total-ivars},")
		builder.add("{ivars-names-loc},")
		builder.dedent
		builder.add(r"};")
		builder.add("")

		# Ivar indices.
		if ivars && ivars.size > 0
			ivar-index = 0
			if superclass
				ivar-index = superclass.total-ivars
			builder.add("enum {{")
			builder.indent
			for ivar: ivars
				builder.add("{c-name}_{mangle-name(ivar)}__index = {ivar-index},")
				ivar-index += 1
			builder.add(r"};")
			builder.dedent
			builder.add("")

		# Functions & classes.
		for kv: functions
			kv.value.emit-top-level(builder)
		if enclosed-classes
			for kv: enclosed-classes
				kv.value.emit-top-level(builder)

		# Function specs.
		# We do this after emitting the functions, so we don't have to
		# forward-declare them.
		if functions.size > 0
			builder.add("static const BuiltinMethodSpec {c-name}__builtin_methods_[] = {{")
			builder.indent
			for kv: functions
				function = kv.value
				num-args = 0
				if function.arguments
					num-args = function.arguments.size
				builder.add('{{ "{function.name}", {num-args}, {function.c-name} }},')
			builder.add(r"{ NULL },")
			builder.add(r"};")
			builder.dedent
			builder.add("")

		builder.cur-class = enclosing-class

	emit(builder)
		# Everything is emitted in emit-top-level(), and anything referencing the
		# class will use ClassRef, so nothing needs to be done here.

	resolve-names(builder)
		if superclass-name
			superclass = builder.context.find(superclass-name)
			if superclass && superclass.is-a(ClassRef)
				superclass = superclass.class-statement
		if !superclass
			superclass = BuiltinClass(Array.superclass) 	# Object
		builder.push-context(ClassContext(self))
		c-name = builder.context.c-prefix
		for kv: functions
			kv.value.resolve-names(builder)
		builder.pop-context
		if enclosed-classes
			builder.push-context(EnclosedClassContext(self))
			for kv: enclosed-classes
				kv.value.resolve-names(builder)
			builder.pop-context

	class ClassContext: Context
		(class-statement)
		init(class-statement-in)
			class-statement = class-statement-in

		find(name)
			# Enclosed class.
			enclosed-class = nil
			if class-statement.enclosed-classes
				enclosed-class = class-statement.enclosed-classes[name]
			if enclosed-class
				return ClassRef(enclosed-class)

			# Self-call.
			function = class-statement.functions[name]
			if function
				return CallExpr(SelfExpr(), name)
			# Self-call of super function.
			cur-class = class-statement.superclass
			while cur-class
				# TODO: handle built-in classes somehow...
				if cur-class.is-a(ClassRef)
					cur-class = cur-class.class-statement
				if cur-class.is-a(ClassStatement)
					if cur-class.functions[name]
						return CallExpr(SelfExpr(), name)
				cur-class = cur-class.superclass

			# Ivar.
			ivar = find-ivar(name)
			if ivar
				return ivar

			return parent && parent.find(name)

		c-prefix
			prefix = parent && parent.c-prefix
			name = mangle-name(class-statement.name)
			if prefix
				return "{prefix}__{name}"
			return name

		find-ivar(name)
			cur-class = class-statement
			while cur-class
				ivar = cur-class.get-ivar(name)
				if ivar
					return ivar
				cur-class = cur-class.superclass

	class EnclosedClassContext: Context
		(class-statement)
		init(class-statement-in)
			class-statement = class-statement-in

		find(name)
			# Enclosed class.
			enclosed-class = nil
			if class-statement.enclosed-classes
				enclosed-class = class-statement.enclosed-classes[name]
			if enclosed-class
				return ClassRef(enclosed-class)

			return parent && parent.find(name)


class CallExpr: ParseNode
	(name, receiver, arguments, got-args)

	init(receiver-in, name-in, arg)
		name = name-in
		receiver = receiver-in
		arguments = []
		if arg
			arguments.append(arg)
			got-args = true
	is-settable
		return true

	add-argument(arg)
		arguments.append(arg)
		got-args = true
	arguments=(new-arguments)
		arguments = new-arguments
		got-args = true
	got-args=(new-got-args)
		got-args = new-got-args

	emit(builder)
		receiver-loc = receiver.emit(builder)
		arg-results = []
		for arg: arguments
			arg-results.append(arg.emit(builder))
		arg-list = "NULL"
		if arg-results.size > 0
			arg-list = "(Object*[]) {{ {arg-results.join(', ')} }}"
		result = builder.new-temp
		builder.add('Object* {result} = call_("{name}", {receiver-loc}, {arg-results.size}, {arg-list});')
		return result

	emit-set(value, builder)
		receiver-loc = receiver.emit(builder)
		arg-results = []
		for arg: arguments
			arg-results.append(arg.emit(builder))
		arg-results.append(value.emit(builder))
		arg-list = "(Object*[]) {{ {arg-results.join(', ')} }}"
		result = builder.new-temp
		builder.add('Object* {result} = call_("{name}=", {receiver-loc}, {arg-results.size}, {arg-list});')
		return result

	resolve-names(builder)
		receiver.resolve-names(builder)
		for arg: arguments
			arg.resolve-names(builder)

class FunctionCallExpr: ParseNode
	(function arguments)

	init(function-in, arguments-in)
		function = function-in
		arguments = arguments-in
	append-arguments(new-arguments)
		arguments += new-arguments

	emit(builder)
		# Certain CallExprs, like self-calls, don't become CallExprs until name
		# resolution happens.  In that case, this is actually just attaching the
		# arguments to that call.
		resolved-fn = function
		if resolved-fn.is-a(Variable)
			resolved-fn = resolved-fn.resolved
		if resolved-fn.is-a(CallExpr)
			if !resolved-fn.got-args
				resolved-fn.arguments = arguments
				return resolved-fn.emit(builder)
		else if resolved-fn.is-a(FunctionCallExpr)
			resolved-fn.append-arguments(arguments)
			return resolved-fn.emit(builder)

		# "Calling" a class is special.
		if resolved-fn.is-a(ClassRef) || resolved-fn.is-a(BuiltinClass)
			# Emit object instantiation.
			class-loc = resolved-fn.emit(builder)
			new-obj = builder.new-temp
			builder.add("Object* {new-obj} = Class_instantiate((Class*) {class-loc});")
			# Emit "init" call (if there is one).
			if resolved-fn.is-a(ClassRef) && !resolved-fn.class-statement.functions["init"]
				# No "init".
				return new-obj
			arg-results = []
			for arg: arguments
				arg-results.append(arg.emit(builder))
			args-text = "NULL"
			if arg-results.size > 0
				args-text = "(Object*[]) {{ {arg-results.join(', ')} }}"
			result = builder.new-temp
			builder.add('Object* {result} = call_("init", {new-obj}, {arg-results.size}, {args-text});')
			return result

		# Will be a FunctionRef.
		fn-loc = resolved-fn.emit(builder)
		result = builder.new-temp
		arg-results = []
		for arg: arguments
			arg-results.append(arg.emit(builder))
		args-needed = 0
		if resolved-fn.is-a(FunctionRef)
			args-needed = resolved-fn.num-args
		else
			# This is probably a builtin function.  Those have up to two arguments;
			# always give them two.
			args-needed = 2
		args-left = args-needed - arguments.size
		while args-left > 0
			arg-results.append(NilLiteral().emit(builder))
			args-left -= 1
		args-text = "NULL"
		if arg-results.size > 0
			args-text = arg-results.join(', ')
			args-text = "(Object*[]) {{ {arg-results.join(', ')} }}"
		builder.add("Object* {result} = {fn-loc}(self, {args-text});")
		return result

	resolve-names(builder)
		if function
			function.resolve-names(builder)
		for arg: arguments
			arg.resolve-names(builder)

class SuperCallExpr: ParseNode
	(name arguments)

	init(name-in)
		name = name-in
	arguments=(new-arguments)
		arguments = new-arguments

	resolve-names(builder)
		for arg: arguments
			arg.resolve-names(builder)

	emit(builder)
		# TODO: include the class needed.  Will need to capture the enclosing
		# class's superclass during resolve-names().
		arg-results = []
		for arg: arguments
			arg-results.append(arg.emit(builder))
		result = builder.new-temp
		arg-list = "NULL"
		if arg-results.size > 0
			arg-list = "(Object*[]) {{ {arg-results.join(', ')} }}"
		builder.add('Object* {result} = super_call_("{name}", self, {arg-results.size}, {arg-list});')
		return result

class SetExpr: ParseNode
	(left right)

	init(left-in, right-in)
		left = left-in
		right = right-in
	emit(builder)
		return left.emit-set(right, builder)
	resolve-names(builder)
		left.resolve-names-autodeclaring(builder)
		right.resolve-names(builder)

class ShortCircuitExpression: ParseNode
	(expr1 expr2 is-and)

	init(expr1-in, expr2-in, is-and-in)
		expr1 = expr1-in
		expr2 = expr2-in
		is-and = is-and-in
	resolve-names(builder)
		expr1.resolve-names(builder)
		expr2.resolve-names(builder)
	emit(builder)
		loc1 = expr1.emit(builder)
		result = builder.new-temp
		builder.add("Object* {result} = {loc1};")
		if is-and
			builder.add("if (IS_TRUTHY({result})) {{")
		else
			builder.add("if (!IS_TRUTHY({result})) {{")
		builder.indent
		loc2 = expr2.emit(builder)
		builder.add("{result} = {loc2};")
		builder.add(r"}")
		builder.dedent
		return result

class ShortCircuitNot: ParseNode
	(expr)

	init(expr-in)
		expr = expr-in
	resolve-names(builder)
		expr.resolve-names(builder)
	emit(builder)
		loc = expr.emit(builder)
		return "make_bool(!IS_TRUTHY({loc}))"

class StringLiteralExpr: ParseNode
	(value)

	init(value-in)
		value = value-in
	append(more-text)
		value += more-text
	emit(builder)
		return '((Object*) new_c_static_String("{c-quote-string(value)}"))'

class IntLiteralExpr: ParseNode
	(value)

	init(value-str)
		value = Int(value-str)
	emit(builder)
		return "((Object*) new_Int({value}))"

class BooleanLiteral: ParseNode
	(value)

	init(value-in)
		value = value-in
	emit(builder)
		if value
			return "&true_obj"
		return "&false_obj"

class NilLiteral: ParseNode
	emit(builder)
		return "NULL"

class Variable: ParseNode
	(name line-number resolved)

	init(name-in, line-number-in)
		name = name-in
		line-number = line-number-in
	is-settable
		return true
	resolve-names(builder)
		if !resolved
			resolved = builder.context.find(name)
			if !resolved
				fail('Couldn\'t find "{name}" on line {line-number}')
	resolve-names-autodeclaring(builder)
		if !resolved
			resolved = builder.context.find-autodeclaring(name)
			if !resolved
				# Probably won't happen, because of the autodeclaration.
				fail('Couldn\'t find "{name}" on line {line-number}')
	emit(builder)
		return resolved.emit(builder)
	emit-set(value, builder)
		return resolved.emit-set(value, builder)

class SelfExpr: ParseNode
	emit(builder)
		return "self"

class InterpolatedStringLiteral: ParseNode
	(segments)

	init(segments-in)
		segments = segments-in
	resolve-names(builder)
		for segment: segments
			segment.resolve-names(builder)
	emit(builder)
		accumulator = builder.new-temp
		builder.add("Array* {accumulator} = new_Array();")
		for segment: segments
			loc = segment.emit(builder)
			builder.add("Array_append({accumulator}, {loc});")
		result = builder.new-temp
		builder.add("Object* {result} = (Object*) Array_join({accumulator}, NULL);")
		return result

class ArrayLiteral: ParseNode
	(items)

	init
		items = []
	add-item(item)
		items.append(item)
	resolve-names(builder)
		for item: items
			item.resolve-names(builder)
	emit(builder)
		result = builder.new-temp
		builder.add("Array* {result} = new_Array();")
		for item: items
			item-loc = item.emit(builder)
			builder.add("Array_append({result}, {item-loc});")
		return "((Object*) {result})"

class DictLiteral: ParseNode
	(items)

	init
		items = {}
	add-item(key, value)
		items[key] = value
	resolve-names(builder)
		for kv: items
			kv.value.resolve-names(builder)
	emit(builder)
		result = builder.new-temp
		builder.add("Dict* {result} = new_Dict();")
		for item: items
			item-loc = item.value.emit(builder)
			builder.add('Dict_set_at({result}, new_c_static_String("{c-quote-string(item.key)}"), {item-loc});')
		return "((Object*) {result})"

class Local: ParseNode
	(name)

	init(name-in)
		name = name-in
	is-settable
		return true
	emit(builder)
		return mangle-name(name)
	emit-set(value, builder)
		mangled-name = mangle-name(name)
		value-loc = value.emit(builder)
		builder.add('{mangled-name} = {value-loc};')
		return mangled-name

class IvarExpr: ParseNode
	(name)
	init(name-in)
		name = name-in
	is-settable
		return true
	emit(builder)
		return "ivar_get_({builder.cur-class.c-ivar-index-name(name)})"
	emit-set(value, builder)
		mangled-name = mangle-name(name)
		value-loc = value.emit(builder)
		builder.add("ivar_set_({builder.cur-class.c-ivar-index-name(name)}, {value-loc});")
		return value-loc

class BuiltinClass: ParseNode
	(builtin-class)
	init(builtin-class-in)
		builtin-class = builtin-class-in
	emit(builder)
		return "((Object*) &{builtin-class.name}_class)"
	superclass
		the-superclass = builtin-class.superclass
		return the-superclass && BuiltinClass(the-superclass)
	get-ivar(name)
		# The built-in classes don't expose their ivars directly by name.
		return nil
	c-ivar-index-name(name)
		return nil
	total-ivars
		return builtin-class.num-ivars
	name
		return builtin-class.name
	c-name
		return builtin-class.name

class BuiltinObject: ParseNode
	(c-code)
	init(c-code-in)
		c-code = c-code-in
	emit(builder)
		return c-code

class ClassRef: ParseNode
	(class-statement)
	init(class-statement-in)
		class-statement = class-statement-in
	emit(builder)
		class-c-name = "{class-statement.c-name}_class"
		builder.add("extern Class {class-c-name};")
		return "(Object*) &{class-c-name}"
	superclass
		return class-statement.superclass
	name
		return class-statement.name
	c-name
		return class-statement.c-name
	get-ivar(name)
		return class-statement.get-ivar(name)
	total-ivars
		return class-statement.total-ivars

class FunctionRef: ParseNode
	(function-statement)
	init(function-statement-in)
		function-statement = function-statement-in
	num-args
		return function-statement.arguments.size
	emit(builder)
		# Note that this doesn't actually reference an object; it will be treated
		# specially by FunctionCallExpr.emit().
		builder.add("extern Object* {function-statement.c-name}(Object* self, Object** args);")
		return function-statement.c-name

class RawLoc: ParseNode
	(name)
	init(name-in)
		name = name-in
	emit(builder)
		return name
	emit-set(value, builder)
		value-loc = value.emit(builder)
		builder.add("{name} = {value-loc};")
		return name

class RunCommand: ParseNode
	(arguments in-pipe-loc out-pipe-loc capture)
	init(arguments-in)
		arguments = arguments-in
	in-pipe-loc=(new-in-pipe-loc)
		in-pipe-loc = new-in-pipe-loc
	out-pipe-loc=(new-out-pipe-loc)
		out-pipe-loc = new-out-pipe-loc
	capture=(new-capture)
		capture = new-capture

	resolve-names(builder)
		for arg: arguments
			arg.resolve-names(builder)
	
	emit(builder)
		# Create the array of arguments.
		args-array = builder.new-temp
		builder.add("Array* {args-array} = new_Array();")
		for arg: arguments
			arg-loc = arg.emit(builder)
			builder.add("Array_append_strings({args-array}, {arg-loc});")

		# Create the options.
		options-loc = "NULL"
		if in-pipe-loc || out-pipe-loc || capture
			options-dict = builder.new-temp
			options-loc = "((Object*) {options-dict})"
			builder.add("Dict* {options-dict} = new_Dict();")
			if in-pipe-loc
				builder.add('Dict_set_at({options-dict}, new_c_static_String("stdin"), {in-pipe-loc});')
			if out-pipe-loc
				builder.add('Dict_set_at({options-dict}, new_c_static_String("stdout"), {out-pipe-loc});')
				# Don't wait for this process, only wait for the last process in the
				# pipeline.
				builder.add('Dict_set_at({options-dict}, new_c_static_String("wait"), &false_obj);')
			else if capture
				builder.add('Dict_set_at({options-dict}, new_c_static_String("capture"), &true_obj);')

		# Emit the call.
		result = builder.new-temp
		builder.add('Object* {result} = Run(NULL, (Object*[]) {{ (Object*) {args-array}, {options-loc} }});')
		return result

class RunPipeline: ParseNode
	(commands capture)
	init
		commands = []
	capture=(new-capture)
		capture = new-capture

	resolve-names(builder)
		for command: commands
			command.resolve-names(builder)

	emit(builder)
		# Make the pipes.
		pipe-locs = []
		pipes-left = commands.size - 1
		while pipes-left > 0
			loc = builder.new-temp
			builder.add('Object* {loc} = Class_instantiate(&Pipe_class);')
			builder.add('call_("init", {loc}, 0, NULL);')
			pipe-locs.append(loc)
			pipes-left -= 1

		# Emit the RunCommands.
		result-loc = builder.new-temp
		which-command = 0
		for command: commands
			# Attach pipes/capture.
			if which-command != 0
				command.in-pipe-loc = pipe-locs[which-command - 1]
			is-last-command = (which-command == commands.size - 1)
			if !is-last-command
				command.out-pipe-loc = pipe-locs[which-command]
			else if capture
				command.capture = true

			# Emit.
			command-result-loc = command.emit(builder)

			if is-last-command
				builder.add("Object* {result-loc} = {command-result-loc};")

			which-command += 1

		# Return the result of the last RunCommand.
		return result-loc

class RunCapture: ParseNode
	(pipeline)
	init(pipeline-in)
		pipeline = pipeline-in
		pipeline.capture = true

	resolve-names(builder)
		pipeline.resolve-names(builder)

	emit(builder)
		run-result-loc = pipeline.emit(builder)
		output-result-loc = builder.new-temp
		builder.add('Object* {output-result-loc} = call_("output", {run-result-loc}, 0, NULL);')
		trim-result-loc = builder.new-temp
		builder.add('Object* {trim-result-loc} = call_("trim", {output-result-loc}, 0, NULL);')
		return trim-result-loc


# Codegen.

fn mangle-name(name)
	return name.replace("-", "_").replace("=", "_eq_")

fn c-quote-string(str)
	remainder = str
	fn next-char
		c = remainder.slice(0, 1)
		remainder = remainder.slice(1)
		return c
	segment-start = remainder
	segment-size = 0
	segments = []
	fn finish-segment
		if segment-size > 0
			segments.append(segment-start.slice(0, segment-size))
		segment-start = remainder
		segment-size = 0
	substitution-list = [
		[ "\x5C" "\x5C\x5C" ], 	# Backslash.
		[ '"', r'\"' ],
		[ "\n" r"\n" ], [ "\r" r"\r" ], [ "\t" r"\t" ], [ "\e" r"\x1B" ],
		[ "\b" r"\b" ], [ "\a" r"\a" ], [ "\v" r"\v" ], [ "\f" r"\f" ],
		]
	substitutions = {}
	for sub: substitution-list
		substitutions[sub[0]] = sub[1]
	while !remainder.is-empty
		c = next-char()
		substitution = substitutions[c]
		if substitution
			finish-segment()
			segments.append(substitution)
		# TODO: other control characters
		else
			segment-size += 1
	finish-segment()
	return segments.join()

class ProgramBuilder
	(context file indentation next-temp-num cur-class all-classes unwindings)

	init(context-in, file-in)
		context = context-in
		file = file-in
		indentation = 0
		next-temp-num = 1
		all-classes = []
		unwindings = []
	cur-class=(new-class)
		cur-class = new-class
	add-class(new-class)
		all-classes.append(new-class)

	add(line)
		file.write(indent-spacers.slice(0, indentation))
		file.write(line)
		file.write("\n")
	indent
		indentation += 1
	dedent
		if indentation > 0
			indentation -= 1

	new-temp
		temp-name = "temp_{next-temp-num}_"
		next-temp-num += 1
		return temp-name

	push-context(new-context)
		new-context.parent = context
		context = new-context
		return ContextCloser(self)
	pop-context
		context = context.parent

	class ContextCloser
		(builder)
		init(builder-in)
			builder = builder-in
		close
			builder.pop-context

	# The unwinding stack is a mixture of ParseNodes to unwind to (loops and
	# functions), and ParseNodes that emit unwindings.
	push-unwinding(node)
		unwindings.append(node)
	pop-unwinding(node)
		old-unwinding = unwindings.pop-back
		if node != old-unwinding
			fail("Internal error: mismatched unwinding.")
	emit-unwind-loop
		index = unwindings.size - 1
		while index >= 0
			unwind-point = unwindings[index]
			if unwind-point.is-loop
				break
			unwind-point.emit-unwind(self)
			index -= 1
	emit-unwind-function
		index = unwindings.size - 1
		while index >= 0
			unwind-point = unwindings[index]
			if unwind-point.is-a(FunctionStatement)
				break
			unwind-point.emit-unwind(self)
			index -= 1



fn dbg(message)
	print(message)

return self-compiler-main()

