<!DOCTYPE html>
<html>

<head>
	<title> sqs Built-in Classes </title>
	<meta charset="utf-8">
	<style>
	span.meta {
		color: gray;
		}
	</style>
</head>

<body>

<h1> sqs Built-in Classes </h1>


<h3> Object </h3>

<p>
<code>Object</code> is the ultimate superclass of all objects.
</p>

<dl>
<dt> string </dt>
<dd>
Returns a string briefly describing the object.  The default method on <code>Object</code> just returns a string showing the object's class, eg. "a Dict" or "an ArrayIterator".  <code>String.string</code> returns the string itself, without surrounding quotes.  <code>Array.string</code> returns a representation of the array with all items listed.
</dd>
<dt> ==(<i>other</i>), !=(<i>other</i>) </dt>
<dd>
By default, these just check if <i>other</i> is the exact same object or not.  This is often overridden, eg. by <code>String</code> or <code>Int</code> to return value equivalence.
</dd>
<dt> is-a(<i>class</i>) </dt>
<dd> Returns whether the object is an instance of <i>class</i>, including the case where <i>class</i> is a superclass of the object's class. </dd>
<dt> class </dt>
<dd> Returns the object's Class. </dt>
</dl>


<h3> Class </h3>

<dl>
<dt> name </dt>
<dd> Returns the class's name. </dd>
<dt> superclass </dt>
<dd> Returns the class's superclass. </dd>
</dl>


<h3> String </h3>

<dl>

<dt> +(<i>other</i>) </dt>
<dd> Adds the other string and returns the result. <dd>

<dt>==(<i>other</i>), !=(<i>other</i>), &lt;(<i>other</i>), &lt;=(<i>other</i>), &gt;(<i>other</i>), &gt;=(<i>other</i>) </dt>
<dd> Comparison operators. </dd>

<dt> strip(<i>other</i>), trim(<i>other</i>) </dt>
<dd> Returns the string with whitespace removed from the start and end.  "strip" and "trim" are synonyms. </dd>
<dt> lstrip(<i>other</i>), ltrim(<i>other</i>) </dt>
<dd> Returns the string with whitespace removed from the start.  "lstrip" and "ltrim" are synonyms. </dd>
<dt> rstrip(<i>other</i>), rtrim(<i>other</i>) </dt>
<dd> Returns the string with whitespace removed from the end.  "rstrip" and "rtrim" are synonyms. </dd>

<dt> slice(<i> start </i>, <i> end </i>) </dt>
<dd>
Returns a slice of the string from the start index (inclusive) to the end index
(non-inclusive).  Indices represent Unicode characters.  If <i>end</i> isn't
given, the end of the string is used.  Negative numbers can be used to index
relative to the end of the string.
</dd>

<dt> split(<span class="meta">[</span><i>delimiter</i><span class="meta">]</span>) </dt>
<dd>
If the <i>delimiter</i> is not given, returns an Array of the whitespace-separated words in the string.
If the <i>delimiter</i> (a String) is given, returns an Array of substrings split at the delimiter.  Unlike the whitespace-based splitting, the result may contain empty strings.
</dd>

<dt> starts-with(<i>other</i>) </dt>
<dt> ends-with(<i>other</i>) </dt>
<dd> Returns whether the string starts or ends with the other string. </dd>

<dt> contains(<i>other</i>) </dt>
<dd> Returns whether the string contains the other string. </dd>

<dt> is-valid </dt>
<dd> Returns whether the string is valid UTF-8. </dd>

<dt> decode-8851-1 </dt>
<dd> Returns another String (in normal UTF-8 encoding) with this String's bytes interpreted as being encoded in ISO-8851-1. </dd>

<dt> bytes </dt>
<dd> Returns a ByteArray containing the bytes of the string, which are assumed to be encoded in UTF-8. </dd>

<dt> size </dt>
<dd> Returns the size, in Unicode characters, of the string. </dd>
<dt> is-empty </dt>
<dd> Returns whether the string is empty.  This is faster than checking if the size is zero. </dd>

<dt> replace(<i>old</i>, <i>new</i>) </dt>
<dd> Returns a new string with all occurrances of <i>old</i> replaced by <i>new</i>.

</dl>


<h3> Int </h3>

<dl>

<dt> + - * / % | &amp; ^ ~ &lt; &gt; &lt;= &gt;= &lt;&lt; &gt;&gt; == != </dt>
<dd> The usual operators are supported. </dt>

<dt> init(<i>value</i>) </dt>
<dd> <i>value</i> can either be another Int, or a String representing an integer. </dd>

<dt> as-utf8 </dt>
<dd> Returns a string of the character at the codepoint represented by the integer. </dd>

</dl>


<h3> Float </h3>

<dl>

<dt> + - * / &lt; &gt; &lt;= &gt;= == != </dt>
<dd>
The usual operators are supported.  Currently, sqs requires some care when
mixing Floats and Ints, because Floats will accept Ints as arguments for
arithmetic operations, but Ints won't accept Floats.  So "3.5 + 2" will work,
but "2 + 3.5" won't.  Also note that Int division returns an Int, not a Float.
</dt>

<dt> init(<i>value</i>) </dt>
<dd> <i>value</i> can either be another Float, an Int, or a String representing an integer. </dd>

</dl>


<h3> Array </h3>

<dl>

<dt> size </dt>
<dd> Returns the size of the array. </dd>
<dt> is-empty </dt>
<dd> Returns whether the array is empty. </dd>

<dt> [](<i>index</i>) </dt>
<dd> Return the item at the index.  Negative indexes select items from the back of the array.  Results in an error if the index is out-of-range. </dd>

<dt> []=(<i>index</i>, <i>value</i>) </dt>
<dd> Sets the item at the index, growing the array if needed. </dd>

<dt> +(<i>other</i>) </dt>
<dd> Returns a new array with the two arrays concatenated. </dd>

<dt> append(<i>value</i>) </dt>
<dd> Adds an item to the end of the array.  Returns the new item. </dd>

<dt> join(<i>string</i>) </dt>
<dd> Returns a string of all the array's items with the string (if given) between them. The items will have the "string" method called on them.  </dd>

<dt> pop(), pop-back() </dt>
<dd> Removes the last item of the array and returns it.  "pop" and "pop-back" are synonyms. </dd>
<dt> pop-front() </dt>
<dd> Removes the first item of the array and returns it. </dd>

<dt> back </dt>
<dd> Returns the last item in the array. </dd>

<dt> slice(<i>start</i>, <span class="meta">[</span><i>end</i><span class="meta">]</span>) </dt>
<dd>
Return a slice of the array from the start index (inclusive) to the end index (non-inclusive).  If <i>end</i> isn't given, the end of the array is used.  Negative numbers can be used to index relative to the end of the Array.
</dd>

<dt> copy </dt>
<dd> Returns a shallow copy of the array. </dd>

<dt> iterator </dt>
<dd> Returns a new iterator on the array.  Mostly used by the <code>for</code> statement. </dd>

<dt> contains(<i>item</i>) </dt>
<dd> Returns whether the array contains the item. </dd>

<dt> remove-index(<i>index</i>) </dt>
<dd> Removes the item at <i>index</i>. <dd>
<dt> remove-item(<i>item</i>) </dt>
<dd> If <i>item</i> is in the array, it is removed.  If there are multiple copies of it, only the first is removed. </dd>

</dl>


<h3> Dict </h3>

<dl>

<dt> [](<i>key</i>) </dt>
<dd> Returns the item at <i>key</i>, which must be a String.  Returns <code>nil</code> if there is no such key.  </dd>

<dt> []=(<i>key</i>, <i>value</i>) </dt>
<dd> Sets or adds an entry in the Dict.  <i>key</i> must be a String. </dd>

<dt> size </dt>
<dd> Returns the number of keys/values in the Dict. </dd>

<dt> contains(<i>key</i>) </dt>
<dd> Returns whether the Dict contains the key. </dd>

<dt> iterator </dt>
<dd> Returns an iterator on the Dict.  Mostly used by the <code>for</code> statement.  The iterator's <code>next</code> method returns an object with <code>key</code> and <code>value</code> methods (or <code>nil</code> when it reaches the end). </dd>

</dl>


<h3> Regex </h3>

The Regex class supports Posix Extended Regular Expression Syntax.  It also supports named groups with the Python-style <code>(?P<<i>name</i>>...)</code> syntax.

<dl>

<dt> init(<i>regular-expression</i>, <span class="meta">[</span><i>options</i><span class="meta">]</span>) <dt>
<dd>
Raw string literals are helpful for <i>regular-expression</i>.  <i>options</i>, if given, is a Dict.  All options are Booleans; the available options are <code>extended-syntax</code> (defaults to <code>true</code>), <code>case-insensitive</code>, and <code>newline</code>.
</dd>

<dt> match(<i>string</i>, <span class="meta">[</span><i>options</i><span class="meta">]</span>) </dt>
<dd> Matches the regular expression against <i>string</i>.  Returns <code>nil</code> if it doesn't match, or a match object if it does.  The match object supports the <code>[]</code> method; <code>match[0]</code> is the whole match, and subsequent integers give the matched groups.  Groups can also be accessed by name if they were given names, eg. <code>match['url']</code>.  The match object also supports a <code>remainder</code> function, which returns the rest of the string after the match.  <i>options</i> are Booleans, and may specify <code>not-bol</code> and/or <code>not-eol</code>. </dd>

</dl>


<h3> File </h3>

<dl>

<dt> init(<i>path</i>, <span class="meta">[</span><i>mode</i><span class="meta">]</span>) </dt>
<dd> Opens the file at <i>path</i>.  <i>mode</i> defaults to "r", and must be one of "r" (read), "r+" (open for reading & writing), "w" (create or truncate to zero length and write), "w+" (create or truncate and open for read and write), "a" (append, file is created if it doesn't exist), or "a+" (open for reading and appending, file is created if it doesn't exist). </dd>

<dt> write(<i>data</i>) </dt>
<dd> Writes the <i>data</i> to the file.  <i>data</i> must be either a String or a ByteArray. </dd>

<dt> read(<i>data</i>) </dt>
<dd> <i>data</i> must be a ByteArray.  This will attempt to read enough to fill the entire ByteArray, and return the number of bytes that it did read.  If it returns zero, the end-of-file has been reached. </dd>

<dt> close() </dt>
<dd> Closes the file.  Usually called by a <code>with</code> statement.  It is an error to call <code>read()</code> or <code>write()</code> on a File after it has been closed. </dd>

<dt> lines </dt>
<dd> Returns an iterator that returns the next line in the file when its <code>next()</code> method is called (or <code>nil</code> when there are no more lines left). </dd>

</dl>


<h3> Path </h3>

<p>
Represents the path of a file or directory in the filesystem.  Basic tilde expansion is done (<code>~</code>, <code>~/foo/bar</code>), but not any more advanced tilde expansion (<code>~someuser/foo</code>).
</p>

<dt> init(<i>string</i>) </dt>
<dd> Creates the path, doing basic tilde expansion. </dd>

<dt> basename, base-name </dt>
<dd> Returns the last component of the path. </dd>

<dt> dirname, dir-name </dt>
<dd> Returns the path without its last component. <dd>

<dt> exists </dt>
<dd> Returns whether a file or directory exists at the path. </dd>

<dt> is-file, is-dir, is-symlink </dt>
<dd> Returns whether a filesystem entry exists at the path and is of that type. </dd>

<dt> can-read, can-write, can-execute </dt>
<dd> Returns whether the current user has permission to do the given operation. </dd>

<dt> size </dt>
<dd> For a file, returns the size of the file in bytes. </dd>


<h3> ByteArray </h3>

<dl>

<dt> init(<span class="meta">[</span><i>size</i><span class="meta">]</span>) <dt>
<dd> If size is given, the new ByteArray has the given size.  If not, it starts out empty. </dd>

<dt> size </dt>
<dd> Returns the number of bytes in the ByteArray. </dd>

<dt> [](<i>index</i>) </dt>
<dd> Returns the integer value of the byte at <i>index</i>. </dd>

<dt> []=(<i>index</i>, <i>value</i>) </dt>
<dd> Sets the byte at <i>index</i>. Grows the ByteArray if needed. </dd>

<dt> append(<i>value</i>) </dt>
<dd> Appends the byte. </dd>

<dt> as-string </dt>
<dd> Returns a String with the bytes in the ByteArray.  Assumes UTF-8 encoding. </dd>

<dt> slice(<i>start</i>, <i>size</i>) </dt>
<dd>
Returns a new ByteArray that's a slice of the original ByteArray.  Setting a byte within the slice will modify the original ByteArray, but setting a byte outside it will cause the slice to be "detached" and become a copy.  <i>start</i> can be negative to index from the end of the ByteArray.  If <i>size</i> is not given, all the bytes starting at <i>start</i> are included.  Note that ByteArray.slice() differs from Array.slice(), in that it uses a <i>size</i> rather than and <i>end</i> as its second argument.
</dd>

<dt> is-valid-utf8 </dt>
<dd> Returns whether the bytes represent valid UTF-8. </dd>

<dt> decode-8851-1 </dt>
<dd> Returns a String (in normal UTF-8 encoding) with the ByteArray's bytes interpreted as being encoded in ISO-8851-1. </dd>
	
</dl>


<h3> Pipe </h3>

<p>
Used for piping data between <code>run()</code> functions.
</p>

<dl>

<dt> init </dt>
<dd> Creates the pipe. </dd>

<dt> close </dt>
<dd> Closes the pipe. </dd>

<dt> capture, read-all </dt>
<dd> Returns a string with all the text that was sent into the pipe.  <code>capture</code> and <code>read-all</code> are synonyms. </dd>

<dt> read(<i>buffer</i>) </dt>
<dd> Reads from the pipe, filling up the <i>buffer</i> (which must be a ByteArray) as much as possible.  Returns the number of bytes read, which will be zero if the write side of the pipe has been closed. </dd>

<dt> write(<i>data</i>) </dt>
<dd> Writes the <i>data</i>, which must be a ByteArray or a String, to the pipe. </dd>

</dl>


</body>
</html>



